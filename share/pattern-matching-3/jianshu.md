æ¨¡å¼åŒ¹é…ç¬¬ä¸‰å¼¹: è‡ªå®šä¹‰çš„æ¨¡å¼åŒ¹é…å’Œè¯­æ³•ç³–"

> ä½œè€…ï¼šOlivier Halligonï¼Œ[åŸæ–‡é“¾æ¥](http://alisoftware.github.io/swift/2016/04/24/pattern-matching-3/)ï¼ŒåŸæ–‡æ—¥æœŸï¼š2015-04-24
> è¯‘è€…ï¼š[walkingway](http://chengway.in/)ï¼›æ ¡å¯¹ï¼š[å°é”…](http://www.swiftyper.com)ï¼›å®šç¨¿ï¼š[numbbbbb](http://numbbbbb.com/)
  









åœ¨æ¨¡å¼åŒ¹é…ç³»åˆ—æ–‡ç« çš„[ç¬¬ä¸€å¼¹](http://swift.gg/2016/04/26/pattern-matching-1/)å’Œ[ç¬¬äºŒå¼¹](http://swift.gg/2016/04/27/pattern-matching-2/)ä¸­ï¼Œæˆ‘ä»¬å·²ç»çœ‹åˆ°å…³äº switch æ­é…å¾ˆå¤šç±»å‹çš„ç”¨æ³•ï¼ŒåŒ…æ‹¬å…ƒç»„ï¼ˆ`tuples`ï¼‰ï¼ŒèŒƒå›´ï¼ˆ`Range`ï¼‰ï¼Œå­—ç¬¦ä¸²ï¼ˆ`String`ï¼‰ï¼Œç¬¦å·ï¼ˆ`Character`ï¼‰å’Œä¸€äº›å…¶ä»–ç±»å‹ã€‚ä½†æ˜¯å‡å¦‚æˆ‘ä»¬ä½¿ç”¨è‡ªå®šä¹‰çš„ç±»å‹å’Œæ¨¡å¼åŒ¹é…ï¼Œåˆèƒ½æ“¦å‡ºæ€æ ·çš„ç«èŠ±å‘¢ï¼Ÿ



## Switch å’Œæ¨¡å¼åŒ¹é…æ“ä½œç¬¦

å¦‚æœä½ åœ¨ `switch` å®ä¾‹ä¸­è¿™æ ·å†™ `case 1900..<2000`ï¼Œé‚£ä¹ˆ Swift å¦‚ä½•æ¯”è¾ƒ switch å…¥å£çš„å•å€¼ä¸ä¸‹é¢çš„èŒƒå›´ï¼Ÿ   

ç­”æ¡ˆéå¸¸ç®€å•ï¼šSwift ä½¿ç”¨äº† `~=` æ“ä½œç¬¦ã€‚å½“ä½ åœ¨ case ä¸­ä½¿ç”¨ `Range<I> `æ—¶ï¼Œswitch å¯ä»¥å¯¹ `I` è¿›è¡ŒåŒ¹é…ï¼Œè¿™æ˜¯å› ä¸º `Range<I>` ä¸ `I` äºŒè€…ä¹‹é—´å®šä¹‰äº† `~=` æ“ä½œç¬¦ï¼š

    
    func ~=<I : ForwardIndexType where I : Comparable>(pattern: Range<I>, value: I) -> Bool

äº‹å®ä¸Šï¼Œå¦‚æœä½ å†™ `switch someI` å¹¶åŠ ä¸Š `case aRangeOfI` è¯­å¥æ—¶ï¼ŒSwift ä¼šå°è¯•è°ƒç”¨ `aRangeOfI ~= someI` æ¥åšåŒ¹é…æ“ä½œï¼ˆè¯¥è¡¨è¾¾å¼ä¼šè¿”å›ä¸€ä¸ª Bool æ¥é€šçŸ¥æ˜¯å¦åŒ¹é…æˆåŠŸï¼‰

è¿™å°±æ„å‘³ç€ä½ å¯ä»¥ä¸ºè‡ªå·±çš„ç±»å‹å®šä¹‰ç›¸åŒçš„æ“ä½œç¬¦ `~=`ï¼Œè¿™æ ·å°±èƒ½ä¿è¯è¿™äº›è‡ªå®šä¹‰ç±»å‹å¯ä»¥åœ¨ `switch/case` è¯­å¥ä¸­ä½¿ç”¨ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨ç›¸åŒçš„æ–¹å¼ä½¿ç”¨ `Range`ï¼

## è®©ä½ çš„è‡ªå®šä¹‰ç±»å‹å“åº”æ¨¡å¼åŒ¹é…

æˆ‘ä»¬æ„é€ ä¸€ä¸ªè‡ªå®šä¹‰çš„ç»“æ„ä½“ï¼š

    
    struct Affine {
      var a: Int
      var b: Int
    }
    
    func ~= (lhs: Affine, rhs: Int) -> Bool {
      return rhs % lhs.a == lhs.b
    }
    
    switch 5 {
    case Affine(a: 2, b: 0): print("Even number")
    case Affine(a: 3, b: 1): print("3x+1")
    case Affine(a: 3, b: 2): print("3x+2")
    default: print("Other")
    }

æœ€ç»ˆæ‰“å°çš„ç»“æœæ˜¯ `3x+2`ï¼

å€¼å¾—æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šåœ¨ä½¿ç”¨è‡ªå®šä¹‰ç±»å‹æ—¶ï¼ŒSwift ä¸çŸ¥é“ switch æ˜¯å¦ç©·å°½äº†æ‰€æœ‰å¯èƒ½ã€‚ä¾‹å¦‚ï¼Œå³ä½¿æˆ‘ä»¬æ·»åŠ äº† `case Affine(a: 2, b: 1)` å’Œ `case Affine(a: 2, b: -1)` è¿™ä¸¤ä¸ªå­å¥ï¼Œæ¥è¦†ç›–åˆ°æ¯ä¸€ä¸ªæ­£æ•´æ•°å’Œè´Ÿæ•´æ•°çš„æƒ…å†µï¼ŒSwift è¿˜æ˜¯ä¼šå¼ºè¿«æˆ‘ä»¬ä½¿ç”¨ `default:` è¯­å¥ã€‚

æ­¤å¤–éœ€è¦æ³¨æ„ï¼Œä¸è¦ææ··äº†å‚æ•°çš„é¡ºåºï¼š`~=` çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼ˆé€šå¸¸ç§°ä¸º `lhs`ï¼Œè¯‘æŒ‡å·¦æ‰‹è¾¹ï¼‰æ˜¯ä½ å°†è¦åœ¨ `case` å­å¥ä¸­ä½¿ç”¨çš„å¯¹è±¡ï¼Œç¬¬äºŒä¸ªå‚æ•°ï¼ˆé€šå¸¸ç§°ä¸º `rhs`ï¼Œè¯‘æŒ‡å³æ‰‹è¾¹ï¼‰æ˜¯ä½ ä½¿ç”¨ switch ä¼ å…¥çš„å¯¹è±¡ã€‚

## ~= çš„ä¸€äº›å…¶ä»–ç”¨é€”

`~=` è¿˜æœ‰å¾ˆå¤šå…¶ä»–ç”¨é€”ã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨[ç¬¬äºŒå¼¹](http://swift.gg/2016/04/27/pattern-matching-2/)ä¸­ç™»åœºçš„ `Book` ç»“æ„ä½“ä¸­æ·»åŠ å¦‚ä¸‹ä»£ç ï¼š

    
    func ~= (lhs: Range<Int>, rhs: Book) -> Bool {
      return lhs ~= rhs.year
    }

ç°åœ¨æµ‹è¯•ä¸€ä¸‹ï¼š

    
    let aBook = Book(title: "20,000 leagues under the sea", author: "Jules Vernes", year: 1870)
    switch aBook {
    case 1800..<1900: print("19th century book")
    case 1900..<2000: print("20th century book")
    default: print("Other century")
    }

å½“ç„¶æˆ‘ä¸é¼“åŠ±è¿™æ ·ä½¿ç”¨ï¼Œå°† Book ç›´æ¥ä¸ä¸€æ®µæ•´æ•°èŒƒå›´æ¯”è¾ƒå¹¶ä¸èƒ½å¾ˆæ¸…æ™°åœ°å±•ç°æˆ‘ä»¬çš„æ„å›¾ï¼šã€å…¶å®æ˜¯æƒ³ä¸ book çš„å‡ºç‰ˆå¹´ä»½è¿›è¡Œæ¯”è¾ƒã€ã€‚æ›´å¥½çš„æ–¹å¼æ˜¯åœ¨ switch ä¸­ç›´æ¥ä¼ å…¥ `aBook.year`ã€‚ä½†æˆ‘ä»¬ä¸¾è¿™ä¸ªä¾‹å­åªæ˜¯ä¸ºäº†å±•ç¤º `~=` æ“ä½œç¬¦çš„å¼ºå¤§(å¦ä¸€ä¸ªåŸå› æ˜¯æˆ‘æš‚æ—¶æƒ³ä¸åˆ°æ›´å¥½çš„ä¾‹å­äº†ğŸ™ƒ)ã€‚

å¦ä¸€ä¸ªä½¿ç”¨ ~= çš„ä¾‹å­æ˜¯åˆ¤å®šä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ã€è¶³å¤Ÿæ¥è¿‘ã€å¦ä¸€ä¸ªã€‚ä¾‹å¦‚ï¼Œä½ æ­£åœ¨åˆ›ä½œä¸€ä¸ªæµ‹è¯•æ¸¸æˆï¼Œå¹¶ä¸”æœŸæœ›ç©å®¶é€šè¿‡é”®ç›˜æ¥è¾“å…¥ç­”æ¡ˆï¼Œå¯¹äºç©å®¶çš„ç­”æ¡ˆï¼Œä½ å¸Œæœ›å¤§å°å†™ä¸æ•æ„Ÿï¼Œå˜éŸ³ç¬¦å·ä¸æ•æ„Ÿï¼Œç”šè‡³å®¹å¿ä¸€äº›å°é”™è¯¯ï¼Œå¯ä»¥åƒä¸‹é¢è¿™æ ·å†™ï¼š

    
    struct Answer {
      let text: String
      let compareOptions: NSStringCompareOptions = [.CaseInsensitiveSearch, .DiacriticInsensitiveSearch, .WidthInsensitiveSearch]
    }
    
    func ~= (lhs: Answer, rhs: String) -> Bool {
      return lhs.text.compare(rhs, options: lhs.compareOptions, range: nil, locale: nil) == NSComparisonResult.OrderedSame
    }
    
    let question = "What's the French word for a face-to-face meeting?"
    let userAnswer = "Tete a Tete"
    
    switch userAnswer {
    case Answer(text: "tÃªte-Ã -tÃªte"): print("Good answer!")
    case Answer(text: "tÃªte Ã  tÃªte"): print("Almostâ€¦ don't forget dashes!")
    default: print("Sorry, wrong answer!")
    }
    // è¾“å‡º "Almostâ€¦ don't forget dashes!"

è§‚å¯Ÿä¸€ä¸‹ï¼Œè¿™ç§æ¯”è¾ƒæ˜¯å¦‚ä½•åœ¨ä¸€ä¸ªåŒºåˆ†å¤§å°å†™ï¼Œå˜éŸ³ç¬¦åˆä¸æ•æ„Ÿï¼Œå®½åº¦ä¸æ•æ„Ÿçš„æ¯”è¾ƒä¸­å¾—åˆ°ä¸€ä¸ªæœ€æ¥è¿‘çš„ç­”æ¡ˆçš„ã€‚

## Optionals çš„è¯­æ³•ç³–

å¦‚æœä½ è®¤ä¸º `switch` å’ŒåŒ¹é…æ¨¡å¼çš„è¯­æ³•ç³–å°±æ˜¯åœ¨ `switch/case` è¯­å¥ä¸­é€æ˜åœ°ä½¿ç”¨ `~=`ï¼Œé‚£åªèƒ½è¯´ä½ ä»¬å‘ **too young too simpleï¼Œsometimes naive**ã€‚

ä½ éœ€è¦äº†è§£çš„å¦ä¸€ä¸ªæœ‰ç”¨çš„è¯­æ³•ç³–å°±æ˜¯ï¼šå½“ switch å¤„ç†ä¸€ä¸ªå¯é€‰å€¼ `x?` æ—¶ï¼Œä½ å¯ä»¥è¯†åˆ«é—®å·æ ‡è®°çš„å¯é€‰å€¼ã€‚

åœ¨è¿™ç§ç‰¹æ®Šçš„ç¯å¢ƒä¸‹ï¼Œä½¿ç”¨ `x?` ä½œä¸ºè¯­æ³•ç³–æ¥è¡¨ç¤º `.Some(x)`ï¼Œè¿™å°±æ„å‘³ç€ä½ å¯ä»¥è¿™æ ·å†™ï¼š

    
    let anOptional: Int? = 2
    switch anOptional {
    case 0?: print("Zero")
    case 1?: print("One")
    case 2?: print("Two")
    case nil: print("None")
    default: print("Other")
    }

äº‹å®ä¸Šï¼Œå¦‚æœä½ ä¸ä½¿ç”¨ ? è€Œæ˜¯ç”¨ `case 2:` æ¥æ›¿ä»£ `case 2?:`ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼š`expression pattern of type 'Int' cannot match values of type 'Int?'` å› ä¸ºä½ å°è¯•å°† `Int(2)` å’Œä¸€ä¸ª `Int?`(å¯é€‰å€¼)è¿›è¡ŒåŒ¹é…ã€‚

ä½¿ç”¨ case 2?: å…¶å®å°±ç²¾å‡†åœ°ç­‰åŒäºå†™ case Optional.Some(2)ï¼Œè¿™ä¸€è¿‡ç¨‹å°†äº§ç”Ÿä¸€ä¸ªå¯é€‰
å€¼ `Int?` åŒ…å«æ•´æ•° `2`ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¼€å¿ƒåœ°åŒ¹é…å¦ä¸€ä¸ªå¯é€‰å€¼ `Int?` äº†ã€‚å°±åƒ `anOptional. case 2?:` å…¶å®æ˜¯ `.Some(2)` çš„ä¸€ç§æ›´ç´§å‡‘çš„å½¢å¼ã€‚

## æ¸¸èµ°åœ¨æšä¸¾å¯¹è±¡ rawValue ä¸Šçš„ Switch

æèµ·è¿™ä¸ªï¼Œæˆ‘æœ€è¿‘æ„å»ºä¸€ä¸ª `UITableView` ä½œä¸ºèœå•æ—¶ï¼Œå¶ç„¶å‘ç°ä¸€äº›ä»£ç å¯ä»¥ä½¿ç”¨æšä¸¾ `enum`ï¼ˆé…åˆ `Int` åŸå§‹å€¼ rawValueï¼‰ æ¥ç»„ç»‡ã€‚æˆ‘ä»¬éšåå¯ä»¥ç›´æ¥æ“ä½œ enum MenuItemï¼ˆæšä¸¾å­èœå•ï¼‰è€Œä¸æ˜¯ `indexPath.row`ï¼Œè¿™ä¸ªæƒ³æ³•æ˜¯ä¸æ˜¯æ£’æäº†å‘¢ï¼

    
    enum MenuItem: Int {
      case Home
      case Account
      case Settings
    }

éšååŸºäº `MenuItem` æ¥å®ç°æ¯ä¸€è¡Œ tableView rowï¼Œä»£ç å¦‚ä¸‹ï¼š

    
    switch indexPath.row {
    case MenuItem.Home.rawValue: â€¦
    case MenuItem.Account.rawValue: â€¦
    case MenuItem.Settings.rawValue: â€¦
    default: ()

é¦–å…ˆï¼Œæ³¨æ„ `switch` æ˜¯å¦‚ä½•å¤„ç† `Int (indexPath.row)` å¹¶ä¸”æ¯ä¸€è¡Œ case å¦‚ä½•ä½¿ç”¨ `rawValue` çš„ã€‚è¿™æ ·åšæ˜¯é”™è¯¯çš„ï¼ŒåŸå› æœ‰å¦‚ä¸‹å‡ ä¸ªï¼š

+ é¦–å…ˆè¿™ç§å†™æ³•ä¸ä¼šé˜»æ­¢ä½ ä½¿ç”¨å…¶ä»–ä»»æ„å€¼ï¼Œæ¯”å¦‚ä¸€ä¸ªå¤åˆ¶ç²˜è´´èƒ½ä½¿ä½ å†™å‡º `case FooBar.Baz.rawValue` ç„¶åç¼–è¯‘å™¨ä¹Ÿä¸ä¼šæŠ±æ€¨ã€‚ä½†æ˜¯ä½ æ˜¯åœ¨å¤„ç† `MenuItems`ï¼Œæ‰€ä»¥è¿˜æ˜¯å¸Œæœ›ç¼–è¯‘å™¨èƒ½å¤Ÿç¡®ä¿æˆ‘ä»¬å¤„ç†çš„æ˜¯ `MenuItems`ï¼Œè€Œä¸æ˜¯å…¶ä»–ä¸œä¸œã€‚
+ å¦ä¸€ä¸ªé—®é¢˜æ˜¯ `switch` è‡ªèº«æ²¡æœ‰ç©·å°½æ‰€æœ‰å¯èƒ½ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆ `default` è¯­å¥æ˜¯å¿…è¦çš„ã€‚æˆ‘å¼ºçƒˆæ¨èä½ å°½é‡ä¸ä½¿ç”¨ `default` è¯­å¥ï¼Œè€Œæ˜¯åœ¨ `switch` ä¸­ç©·å°½æ‰€æœ‰å¯èƒ½ï¼ŒæŒ‰ç…§è¿™ç§æ–¹å¼å¦‚æœä½ æ–°æ·»åŠ ä¸€ä¸ªå€¼åˆ°æšä¸¾å¯¹è±¡ä¸­ï¼Œä½ ä¸ç”±è‡ªä¸»åœ°ä¼šå¼ºè¿«è‡ªå·±å»æ€è€ƒå¦‚ä½•å»åšè€Œä¸æ˜¯ä»€ä¹ˆéƒ½ä¸å»æƒ³ï¼Œæ›´ä¸ä¼šéƒ½ä¾èµ– `default` æ¥å¤„ç†é‚£äº›å› ä¸ºä½ æ‡’è€Œæ²¡æœ‰æ„è¯†çš„æƒ…å½¢ã€‚

ä¸ºäº†æ›¿ä»£ `switch` ä¸­çš„ `indexPath` å’Œ `case â€¦.rawValue`ï¼Œä½ åº”è¯¥ä¸€å¼€å§‹å°±ä¾èµ– rawValue æ„å»ºæšä¸¾å¯¹è±¡ enmuï¼Œé€šè¿‡è¿™ç§æ–¹å¼ï¼Œä½ åœ¨ switch ä¸­ä½¿ç”¨æšä¸¾å¯¹è±¡çš„ cases å°±è¶³å¤Ÿäº†ï¼Œå³ä½¿ç”¨ `MenuItem` æšä¸¾å¯¹è±¡çš„ casesï¼Œè€Œä¸æ˜¯åƒ `FooBar.Baz` ä¹‹ç±»çš„ä¸œä¸œã€‚

è¿™æ ·åšï¼Œå› ä¸º `MenuItem(rawValue:)` æ˜¯ä¸€ä¸ªå…è®¸å¤±è´¥çš„åˆå§‹åŒ–ç¨‹åºï¼Œäº‹å®ä¸Šè¯¥æ–¹æ³•è¿”å›çš„ä¹Ÿæ˜¯ä¸€ä¸ªå¯é€‰å€¼ `MenuItem?`ï¼Œå¯ä»¥ç”¨åˆ°æˆ‘ä»¬ä¸Šé¢æåˆ°è¿‡çš„è¯­æ³•ç³–è€¶ï¼

    
    switch MenuItem(rawValue: indexPath.row) {
    case .Home?: â€¦
    case .Account?: â€¦
    case .Settings?: â€¦
    case nil: fatalError("Invalid indexPath!")
    }

è€å®è¯´ï¼Œå¯¹äºé‚£ç§æƒ…å½¢æˆ‘æ›´ä¹ æƒ¯ä½¿ç”¨ `guard let`ï¼Œè€Œä¸”æˆ‘å‘ç°è¿™ç§æ–¹å¼æ¯”åœ¨æ¯ä¸ª `case` ä¸­ä½¿ç”¨ `?` æ›´å…·å¯è¯»æ€§ï¼š

    
    guard let menuItem = MenuItem(rawValue: indexPath.row) else { fatalError("Invalid indexPath!") }
    switch menuItem {
    case .Home: â€¦
    case .Account: â€¦
    case .Settings: â€¦
    }

æ˜¯ä¸æ˜¯æœ‰ç‚¹çµæ´»ï¼Œäº†è§£ä¸€ä¸‹æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©æ€»å½’ä¸æ˜¯ä¸€ä»¶åäº‹ã€‚

## æ€»ç»“

è¿™å°±æ˜¯ä»Šå¤©æˆ‘è¦è¯´çš„ï¼Œåœ¨è¿™ä¸€ç³»åˆ—æ–‡ç« çš„ä¸‹ä¸€ç¯‡ï¼ˆæˆ–è®¸æ˜¯æœ€åä¸€ç¯‡ï¼‰ä¸­ï¼Œæˆ‘ä¼šè¯´è¯´å¦‚ä½•åœ¨å…¶ä»–åœºæ™¯ä¸‹ä½¿ç”¨æ¨¡å¼åŒ¹é…ã€‚æˆ‘ä»¬ä¸ä¼šå±€é™åœ¨ `switch` ä¸Šï¼Œä¼šè®²è®²åœ¨ `if`, `guard` å’Œ `for` å¾ªç¯ä¸­å¦‚ä½•ä½¿ç”¨æ¨¡å¼åŒ¹é…ï¼Œå¹¶å°†å¤§å®¶å¯¹æ¨¡å¼åŒ¹é…çš„è®¤è¯†æå‡åˆ°ä¸€ä¸ªæ–°çš„é«˜åº¦ï¼Œè®©æˆ‘ä»¬æ‹­ç›®ä»¥å¾…å§ã€‚
> æœ¬æ–‡ç”± SwiftGG ç¿»è¯‘ç»„ç¿»è¯‘ï¼Œå·²ç»è·å¾—ä½œè€…ç¿»è¯‘æˆæƒï¼Œæœ€æ–°æ–‡ç« è¯·è®¿é—® [http://swift.gg](http://swift.gg)ã€‚